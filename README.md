# Vault Database Injector ?

The injector is a go application that contain a renewer, a revoker and the injector itself.

##  1. <a name='TableofContent'></a>Table of Content

<!-- vscode-markdown-toc -->
* 1. [Table of Content](#TableofContent)
* 2. [Vault-Injector](#Vault-Injector)
	* 2.1. [Mechanism](#Mechanism)
		* 2.1.1. [Vault Injector:](#VaultInjector:)
	* 2.2. [Diagram](#Diagram)
	* 2.3. [Vault Usage](#VaultUsage)
	* 2.4. [Authentication](#Authentication)
	* 2.5. [How token are handled ?](#Howtokenarehandled)
	* 2.6. [How does injector work then ?](#Howdoesinjectorworkthen)
	* 2.7. [Usage :](#Usage:)
		* 2.7.1. [In mode classic](#Inmodeclassic)
		* 2.7.2. [In mode URI](#InmodeURI)
		* 2.7.3. [With multiple databases](#Withmultipledatabases)
	* 2.8. [Configuration](#Configuration)
		* 2.8.1. [Mode Injector](#ModeInjector)
		* 2.8.2. [Mode token-renewer](#Modetoken-renewer)
		* 2.8.3. [Mode token-renewer](#Modetoken-renewer-1)
	* 2.9. [Vault policy](#Vaultpolicy)
	* 2.10. [Terraform](#Terraform)
		* 2.10.1. [Configuration Terraform pour les utilisateurs pour accéder aux ressources](#ConfigurationTerraformpourlesutilisateurspouraccderauxressources)
	* 2.11. [Prometheus Metrics](#PrometheusMetrics)
* 3. [Monitoring](#Monitoring)
	* 3.1. [We have a grafana dashboard](#Wehaveagrafanadashboard)
	* 3.2. [We also have Alertmanager alerts](#WealsohaveAlertmanageralerts)
* 4. [TODO](#TODO)
* 5. [Contribution](#Contribution)
* 6. [License](#License)
* 7. [Acknowledgements](#Acknowledgements)

<!-- vscode-markdown-toc-config
	numbering=true
	autoSave=true
	/vscode-markdown-toc-config -->
<!-- /vscode-markdown-toc -->


##  2. <a name='Vault-Injector'></a>Vault-Injector

The Vault DB Injector is a Go program that is design to retrieve databases credentials from Hashicorp Vault, it use Kubernetes Mutating Webhook to intercept pod creation activated with a label and configured with annotations.
After the credentials are provided, it will store them in a specific Vault KV and will handle the lifecycle of them such as : 
- Renew them periodically
- Revoke them after the pod is deleted 

###  2.1. <a name='Mechanism'></a>Mechanism

####  2.1.1. <a name='VaultInjector:'></a>Vault Injector:

1. Connects to Vault to generate credentials.
2. Vault will create a temporary role in PostgreSQL for the database.
3. Retrieves the credentials via Vault.
4. Modifies the pod by adding the credentials in the form of environment variables.
5. The pod can now connect to the database.
6. Handle token / lease renewing and revokation.

###  2.2. <a name='Diagram'></a>Diagram

![Diagram](images/vault-injector-schema.png)

###  2.3. <a name='VaultUsage'></a>Vault Usage

Their is also a fonctionnality that permit to rotate token directly from the injector. Objectif is to keep token as secure as possible.
For this purpose, we have made the choice to store the token directly on Vault in a specific KV.
We provide a generated random UUID to every pod which will be use as a unique identifier. As long as the pod is alive, the injector will rotate
his token 5 minutes by default. If the pods is deleted, the revoker will revoke the token and the lease and the renewer which is design to keep the state will also delete the secret in the KV.

If the injector reboot or fail for any reason, the token can stil be renewed manually or by restarting the injector correctly. He can retrieve 
all token that was created previously.
The renewer will renew all tokens and leases every 5 minutes by default.

We are using periodic token for this purpose which need absolutely "sudo" policy.
Periodic token permit to add a max_ttl and to have infinite token that can be renewed until the pod is deleted.
Token TTL permit to fix the max_ttl of the token which mean : "How many time my token can belong without been renewed."
By default, if the token is not renewed, hes timelife is 32 days, that mean, if the injector fail, you have 31 days and 23 hours before all your token will expire, which i think is enough to understand why and repair it to a working state.

With this setup, the advantage is that now, vault is the only real SPOF.
The Injector in renewer mode will only renew TOKEN and LEASE and cleanup KV/STORE that has been created by the Injector.
The Injector in revoker mode will only revoke TOKEN when a pod has been deleted
If the revoker fail to revoke a Token, the renewer can do it periodically every 5 minutes (This will be probably removed in future version.)

###  2.4. <a name='Authentication'></a>Authentication

It uses a service account and the Kubernetes mount point to retrieve and generate its information. It then sends the following information to the application:

- Username: A database user generated by Vault.
- Password: A database password generated by Vault.

It will store on a specific vault KV/Store the following : 

- LeaseID
- TokenID
- Namespace
- UUID

###  2.5. <a name='Howtokenarehandled'></a>How token are handled ?

They are two kind of token that are created in the lifecycle of the Vault injector : 

1. Token created for the Injector using `kubeRole: ` in the yaml config
   - Permit to generate OrphanToken for our pods that will access to DB
   - Permit to renew and revoke all the OrphanToken
   - Permit to store data token inside the KV from `vaultSecretName: vault-injector` and prefix : `vaultSecretPrefix: kubernetes1-dv-par5`
   - TTL is 1h but will always be revoked after the tasks is completed.
   - This token will be revoked after the webhook is generated.
2. OrphanToken created on a webhook request which are stored on Vault with the pods UUID and configured by annotation `db-creds-injector.numberly.io/role:` and `db-creds-injector.numberly.io/dbname.role:`
   - Permit to generate the LeaseId that will be provided to the pod
   - Permit to generate the DB credentials
   - Will be revoked when the pod is deleted
   - Is a periodic token with TTL : `tokenTTL: 768h`

###  2.6. <a name='Howdoesinjectorworkthen'></a>How does injector work then ?

1. A new pod is created with label `vault-db-injector: "true"`, annotations `db-creds-injector.numberly.io/cluster:` & `db-creds-injector.numberly.io/role:` and a serviceaccount
2. The api-server use mutating-webhook to send the pods template to the injector
3. The injector will generate a new orphan token and do thoses steps : 
   - Does the serviceaccount attached to my pod is allowed to assume my role on Vault. If the SA or the namespace is no't allowed, it will return an error, else, it will continue the process.
   - Generate a new orphan token with a specific period and the policy provided in the annotation by the pod.
   - Generate an UUID and add a specific annotation on the pod with IT
   - Ask vault to generate DB Credentials for the pods with the new Orphan Token
   - Store on vault on the specific KV the `LeaseId`, `TokenId`, `namespace` in a folder named with the pod UUID
   - Revoke all intermediate Token
4. The injector will return back to the api-server with a modified pod template
5. The api-server will create the new pods with modified informations

The available annotations can be declare like this : 

- `db-creds-injector.numberly.io/cluster`, [OPTIONAL] default to `databases` which is the database engine to use
- `db-creds-injector.numberly.io/role`, [MANDATORY] Role to be use to get db credentials
- `db-creds-injector.numberly.io/dbname.role`, [OPTIONAL] Role to be use to get db credentials for this specific database
- `db-creds-injector.numberly.io/dbname.env-key-dbuser`, [OPTIONAL] overwrite DB user env variable, default to `DBUSER`
- `db-creds-injector.numberly.io/dbname.env-key-dbpassword`, [OPTIONAL] overwrite DB password env variable, default to `DBPASSWORD`
- `db-creds-injector.numberly.io/dbname.mode`, [MANDATORY] the mode for the injector, default to `classic`.

###  2.7. <a name='Usage:'></a>Usage : 

####  2.7.1. <a name='Inmodeclassic'></a>In mode classic
```yaml
# To be added in the pod spec
annotations:
  db-creds-injector.numberly.io/cluster: databases
  db-creds-injector.numberly.io/dbname.env-key-dbpassword: DB_PASSWORD
  db-creds-injector.numberly.io/dbname.env-key-dbuser: DB_USER
  db-creds-injector.numberly.io/dbname.role: db-role # the one created from vault with terraform
  db-creds-injector.numberly.io/dbname.mode: classic
labels:
  vault-db-injector: "true"
```

####  2.7.2. <a name='InmodeURI'></a>In mode URI
```yaml
annotations:
  db-creds-injector.numberly.io/cluster: databases
  db-creds-injector.numberly.io/dbname.template: postgres://@postgres-server.tld:5432/dbname?sslmode=require
  db-creds-injector.numberly.io/dbname.role: db-role
  db-creds-injector.numberly.io/dbname.env-key-uri: POSTGRES_URL
  db-creds-injector.numberly.io/dbname.mode: uri
labels:
  vault-db-injector: "true"
```

####  2.7.3. <a name='Withmultipledatabases'></a>With multiple databases
```yaml
annotations:
  db-creds-injector.numberly.io/cluster: databases
  db-creds-injector.numberly.io/dbname.env-key-dbpassword: DB_PASSWORD
  db-creds-injector.numberly.io/dbname.env-key-dbuser: DB_USER
  db-creds-injector.numberly.io/dbname.role: db-role # the one created from vault with terraform
  db-creds-injector.numberly.io/dbname.mode: classic
  db-creds-injector.numberly.io/other_dbname.template: postgres://@postgres-server.tld:5432/dbname?sslmode=require
  db-creds-injector.numberly.io/other_dbname.role: another-vault-role
  db-creds-injector.numberly.io/other_dbname.env-key-uri: POSTGRES_URL,ANOTHER_ENV
  db-creds-injector.numberly.io/other_dbname.mode: uri
labels:
  vault-db-injector: "true"
```
Here, as you can see, we can connect to 2 databases `dbname` and `other_dbname`.

###  2.8. <a name='Configuration'></a>Configuration

Here is the configuration for Vault Injector:

####  2.8.1. <a name='ModeInjector'></a>Mode Injector
The Injector mode is basic one that will handle all api-server request and handle all requests to vault to generate credentials to our DB
The config file path can be parse by adding the path with : `- "--config=/injector/config.yaml"`
```yaml
certFile: /tls/tls.crt
keyFile: /tls/tls.key
vaultAddress: https://vault1.tld:8200
vaultAuthPath: pgsql2-dv-kubernetes1-dv-par5
logLevel: info
kubeRole: all-rw
tokenTTL: 768h
vaultSecretName: vault-injector
vaultSecretPrefix: kubernetes1-dv-par5
mode: injector
sentry: true
sentryDsn: https://my-sentry-url@sentry.tld/660
injectorLabel: vault-db-injector
defaultEngine: databases
```

####  2.8.2. <a name='Modetoken-renewer'></a>Mode token-renewer
The Renewer one is a process that will run every hour and validate that all orphan token won't expire before pod is deleted 
The config file path can be parse by adding the path with : `- "--config=/renewer/config.yaml"`
```yaml
vaultAddress: https://vault1.tld:8200
vaultAuthPath: pgsql2-dv-kubernetes1-dv-par5
logLevel: info
kubeRole: all-rw
tokenTTL: 768h
vaultSecretName: vault-injector
vaultSecretPrefix: kubernetes1-dv-par5
mode: renewer
sentry: true
sentryDsn: https://my-sentry-url@sentry.tld/660
SyncTTLSecond: 300
injectorLabel: vault-db-injector
defaultEngine: databases
```

####  2.8.3. <a name='Modetoken-renewer-1'></a>Mode token-renewer
The Revoker one is a process that is going to watch pod deletion Kubernetes events filtered with the label `vault-db-injector: true` and will revoke token attached to the pod when it is deleted 
The config file path can be parse by adding the path with : `- "--config=/revoker/config.yaml"`
```yaml
vaultAddress: https://vault1.tld:8200
vaultAuthPath: pgsql2-dv-kubernetes1-dv-par5
logLevel: info
kubeRole: all-rw
tokenTTL: 768h
vaultSecretName: vault-injector
vaultSecretPrefix: kubernetes1-dv-par5
mode: revoker
sentry: true
sentryDsn: https://my-sentry-url@sentry.tld/660
injectorLabel: vault-db-injector
defaultEngine: databases
```

###  2.9. <a name='Vaultpolicy'></a>Vault policy
There is the policy to use for the injector
```json
path "vault-injector/*" {
  capabilities = ["read", "list", "update", "create", "delete", "sudo"]
}
path "vault-injector/data/*" {
  capabilities = ["read", "list", "update", "create", "delete", "sudo"]
}
path "vault-injector/metadata/*" {
  capabilities = ["read", "list", "update", "create", "delete", "sudo"]
}
path "pgsql2-dv/creds/*" {
  capabilities = ["read"]
}
path "auth/pgsql2-dv-kubernetes1-dv-par5/role/*" {
  capabilities = ["read"]
}
path "sys/leases/renew" {
  capabilities = ["create"]
}
path "auth/token/renew-self" {
  capabilities = ["create"]
}
path "auth/token/renew" {
  capabilities = ["create", "update"]
}
path "auth/token/revoke" {
  capabilities = ["create", "update"]
}
path "auth/token/create" {
  capabilities = ["create", "update", "read"]
}

path "auth/token/create-orphan" {
  capabilities = ["create", "update", "read", "sudo"]
}
path "auth/token/revoke-orphan" {
  capabilities = ["create", "update", "sudo"]
}
```

###  2.10. <a name='Terraform'></a>Terraform

Here is the Terraform with the desired resource for the vault injector to work properly : 
```yaml
resource "vault_kubernetes_auth_backend_role" "all_rw" {
  backend                          = vault_auth_backend.k8s_1_dv_par5.path
  role_name                        = "all-rw"
  bound_service_account_names      = ["kube-vault-db-injector"]
  bound_service_account_namespaces = ["vault-injector"]
  token_ttl                        = 3600
  token_policies                   = [vault_policy.all_rw.name]
  token_bound_cidrs                = ["10.19.0.0/16"]
}

resource "vault_policy" "all_rw" {
  name = "all-rw"

  policy = <<EOT
path "vault-injector/*" {
  capabilities = ["read", "list", "update", "create", "delete", "sudo"]
}
path "vault-injector/data/*" {
  capabilities = ["read", "list", "update", "create", "delete", "sudo"]
}
path "vault-injector/metadata/*" {
  capabilities = ["read", "list", "update", "create", "delete", "sudo"]
}
path "pgsql2-dv/creds/*" {
  capabilities = ["read"]
}
path "auth/pgsql2-dv-kubernetes1-dv-par5/role/*" {
  capabilities = ["read"]
}
path "sys/leases/renew" {
  capabilities = ["create"]
}
path "auth/token/renew-self" {
  capabilities = ["create"]
}
path "auth/token/renew" {
  capabilities = ["create", "update"]
}
path "auth/token/revoke" {
  capabilities = ["create", "update"]
}
path "auth/token/create" {
  capabilities = ["create", "update", "read"]
}

path "auth/token/create-orphan" {
  capabilities = ["create", "update", "read", "sudo"]
}
path "auth/token/revoke-orphan" {
  capabilities = ["create", "update", "sudo"]
}
EOT
}
```

####  2.10.1. <a name='ConfigurationTerraformpourlesutilisateurspouraccderauxressources'></a>Configuration Terraform pour les utilisateurs pour accéder aux ressources

Here is the Terraform configuration allowing an application to perform vault db credentials
This configuration allow the serviceaccount vault-pgsql-example on the namespace team-infrastructure on the demo-rw database

```yaml
resource "vault_kubernetes_auth_backend_role" "gule_rw" {
  backend                          = vault_auth_backend.k8s_1_dv_par5.path
  role_name                        = "gule-rw"
  bound_service_account_names      = ["vault-pgsql-example"]
  bound_service_account_namespaces = ["team-infrastructure"]
  token_ttl                        = 3600
  token_policies                   = [vault_policy.gule_rw.name]
  token_bound_cidrs                = ["10.19.0.0/16"]
}

resource "vault_policy" "gule_rw" {
  name = "gule-rw"

  policy = <<EOT
path "pgsql2-dv/creds/gule-rw" {
  capabilities = ["read"]
}
path "sys/leases/revoke" {
  capabilities = ["update"]
}
path "sys/leases/renew" {
  capabilities = ["create"]
}
EOT
}

resource "vault_database_secret_backend_role" "gule_rw" {
  backend     = vault_mount.pgsql2.path
  name        = "gule-rw"
  db_name     = vault_database_secret_backend_connection.pgsql2_dv.name
  default_ttl = 3600
  creation_statements = [
    "CREATE ROLE \"{{name}}\" WITH LOGIN PASSWORD '{{password}}' VALID UNTIL '{{expiration}}' IN ROLE \"demo-rw\";",
    "ALTER ROLE \"{{name}}\" SET ROLE \"demo-rw\";",
  ]
  revocation_statements = [
    "DROP ROLE \"{{name}}\";"
  ]
}

resource "vault_database_secret_backend_connection" "pgsql2_dv" {
  backend = vault_mount.pgsql2.path
  name    = "pgsql2_dv"
  allowed_roles = [
    "gule-rw"
  ]

  postgresql {
    connection_url    = "postgres://{{username}}:{{password}}@rw-pgsql2-dv.numberly.in:5432/postgres?sslmode=verify-full"
    username          = data.vault_generic_secret.pgsql2_dv_vault_login.data["username"]
    password          = data.vault_generic_secret.pgsql2_dv_vault_login.data["password"]
    username_template = "{{.RoleName}}-{{unix_time}}-{{random 8}}"
  }
}
```

###  2.11. <a name='PrometheusMetrics'></a>Prometheus Metrics

Our application exports several Prometheus metrics for monitoring and observability purposes. Below are the details of the available metrics:


| Metric Name                                          | Description                                                               | Labels                                |
|--------------------------------------------------    |---------------------------------------------------------------------------|---------------------------------------|
| `vault_injector_renew_token_count_success`           | Vault injector token renewed with success count                           | `uuid`, `namespace`                   |
| `vault_injector_renew_token_count_error`             | Vault injector token renewed with error count                             | `uuid`, `namespace`                   |
| `vault_injector_renew_lease_count_success`           | Vault injector lease renewed with success count                           | `uuid`, `namespace`                   |
| `vault_injector_renew_lease_count_error`             | Vault injector lease renewed with error count                             | `uuid`, `namespace`                   |
| `vault_injector_revoke_token_count_success`          | Vault injector token revoked with success count                           | `uuid`, `namespace`                   |
| `vault_injector_revoke_token_count_error`            | Vault injector token revoked with error count                             | `uuid`, `namespace`                   |
| `vault_injector_token_expiration`                    | Vault injector expiration time for tokens                                 | `uuid`, `namespace`                   |
| `vault_injector_lease_expiration`                    | Vault injector expiration time for leases                                 | `uuid`, `namespace`                   |
| `vault_injector_token_last_renewed`                  | Last vault token successful renewal                                       | `uuid`, `namespace`                   |
| `vault_injector_synchronization_count_success`       | Vault injector synchronization with success                               |                                       |
| `vault_injector_synchronization_count_error`         | Vault injector synchronization with error                                 |                                       |
| `vault_injector_pod_cleanup_count_success`           | Vault injector PodCleanup with success                                    |                                       |
| `vault_injector_pod_cleanup_count_error`             | Vault injector PodCleanup with error                                      |                                       |
| `vault_injector_last_synchronization_success`        | Last vault token successful renewal                                       |                                       |
| `vault_injector_orphan_ticket_created_count_success` | Vault injector orphan ticket created with success                         |                                       |
| `vault_injector_orphan_ticket_created_count_error`   | Vault injector orphan ticket created with error                           |                                       |
| `vault_injector_store_data_count_success`            | Vault injector data stored with success                                   | `uuid`, `namespace`                   |
| `vault_injector_store_data_count_error`              | Vault injector data stored with error                                     | `uuid`, `namespace`                   |
| `vault_injector_delete_data_count_success`           | Vault injector data delete with success                                   | `uuid`, `namespace`                   |
| `vault_injector_delete_data_count_error`             | Vault injector data deleted with error                                    | `uuid`, `namespace`                   |
| `vault_injector_connect_vault_count_success`         | Vault injector connect to vault with success                              |                                       |
| `vault_injector_connect_vault_count_error`           | Vault injector connect to vault with error                                |                                       |
| `vault_injector_service_account_authorized_count`    | Vault injector service account is authorized to assume dbRole             |                                       |
| `vault_injector_service_account_denied_count`        | Vault injector service account is not authorized to assume dbRole         | `service_account_name`, `namespace`, `db_role`, `cause` |
| `vault_injector_last_synchronization_duration`       | Vault injector last duration of synchronization                           |                                       |
| `vault_injector_is_leader`                           | Return 1 if the vault injector is leader, else 0                          | `lease_name`                          |
| `vault_injector_leader_election_attempts_total`      | Total number of attempts to acquire leadership                            | `lease_name`                          |
| `vault_injector_leader_election_duration_seconds`    | Duration in seconds that this instance has been the leader                | `lease_name`, `leader_name`, `mode`   |
| `vault_injector_fetch_pods_success_count`            | Count that increase when their is no error retrieving pods                |                                       |
| `vault_injector_fetch_pods_error_count`              | Count that increase when their is an error retrieving pods                |                                       |
| `vault_injector_mutated_pods_error_count`            | Count that increase when their is an error mutating pods                  |                                       |
| `vault_injector_mutated_pods_error_count`            | Count that increase when their is an error mutating pods                  |                                       |

##  3. <a name='Monitoring'></a>Monitoring
###  3.1. <a name='Wehaveagrafanadashboard'></a>We have a grafana dashboard
You can found the json file [here](./docs/dashboard.json)
![Grafana](images/grafana.png)

###  3.2. <a name='WealsohaveAlertmanageralerts'></a>We also have Alertmanager alerts 
Which you can found [here](./docs/alertmanager.md)

##  4. <a name='TODO'></a>TODO

- OK : Ajouter les metrics prometheus sur l'ensemble des call pour pouvoir monitorer très granulairement l'applications.
- OK : Améliorer les logs parce que c'est partie un peu en cacahouétte.
- OK : Système de lock, use leaderelection with Kubernetes Lease
- OK : Migrer le système de config de flag vers un fichier de configuration
- OK : Gestion du multi-dc/cluster (sois on a un secret engine par DC, soit faut implémenté une petite feature de prefix).
- NOK : Trouver un mechanisme pour interdir l'utilisation de : `db-creds-injector.numberly.io/uuid` autre que par l'injector avec Kyverno
- NOK : Alerte si on trouve un `db-creds-injector.numberly.io/uuid` dans kube mais pas dans vault.
- OK : à tester : Ne pas supprimer les secrets si on arrive pas à récupérer la liste des Pods
- OK : Séparer la partie renewing et la partie injecting dans des applications différentes
- OK : Lance la synchronisation au lancement de l'application
- OK : Vérifier si le service_account du pod match avec le role utilisé dans Vault pour récupérer les creds, sinon erreur.
- OK : Metrics prometheus sur le matchi od, using is own SA
- OK : Ajout d'une metrics permettant de connaitre le temps de la dernière synchronisation (ce qui nous permettra de mettre des erreurs si c'est trop long par example.)
- OK : Add sentry
- OK : Liveness and Readiness

##  5. <a name='Contribution'></a>Contribution

Contributions to the Kube-Vault-DB-Injector are welcome. Please submit your pull requests or issues to the project's GitLab repository.

##  6. <a name='License'></a>License


##  7. <a name='Acknowledgements'></a>Acknowledgements

Special thanks to the contributors and maintainers of the project.

---
