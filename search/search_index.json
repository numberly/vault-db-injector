{"config":{"lang":["en","fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Vault DB Injector","text":""},{"location":"#overview","title":"Overview","text":"<p>The Vault DB Injector is a Kubernetes-based application designed to dynamically generate database credentials using HashiCorp Vault and provide them as environment variables to Kubernetes Pods. The application leverages a Mutating Webhook to achieve this functionality, ensuring secure and automated management of database credentials.</p> <p></p>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#1-dynamic-database-credential-injection","title":"1. Dynamic Database Credential Injection","text":"<ul> <li>Description: Automatically generates and injects database credentials into Kubernetes Pods at runtime using HashiCorp Vault.</li> <li>Benefit: Enhances security by avoiding static credentials and ensuring credentials are rotated and managed dynamically.</li> </ul>"},{"location":"#2-mutating-webhook","title":"2. Mutating Webhook","text":"<ul> <li>Description: Uses Kubernetes Mutating Admission Webhook to modify pod specifications on-the-fly and inject the necessary environment variables.</li> <li>Benefit: Seamlessly integrates with Kubernetes, providing a transparent and automated way to manage secrets.</li> </ul>"},{"location":"#3-configuration-management","title":"3. Configuration Management","text":"<ul> <li>Description: Supports configuration through YAML files and environment variables.</li> <li>Benefit: Offers flexibility and ease of configuration for different deployment environments.</li> </ul>"},{"location":"#4-error-monitoring-with-sentry","title":"4. Error Monitoring with Sentry","text":"<ul> <li>Description: Integrates with Sentry to capture and report errors.</li> <li>Benefit: Provides robust error tracking and monitoring, helping maintain application reliability and performance.</li> </ul>"},{"location":"#5-logging","title":"5. Logging","text":"<ul> <li>Description: Utilizes <code>logrus</code> for structured logging, supporting various log levels and JSON formatting.</li> <li>Benefit: Ensures clear and consistent logging, aiding in debugging and monitoring.</li> </ul>"},{"location":"#6-kubernetes-integration","title":"6. Kubernetes Integration","text":"<ul> <li>Description: Provides utilities for interacting with the Kubernetes API, including service account token retrieval and client initialization.</li> <li>Benefit: Facilitates seamless integration with Kubernetes clusters, enhancing the application's capabilities and ease of use.</li> </ul>"},{"location":"#7-leader-election","title":"7. Leader Election","text":"<ul> <li>Description: Implements leader election using Kubernetes resource locks to ensure high availability and fault tolerance.</li> <li>Benefit: Ensures that critical tasks are performed by a single instance in a distributed system, enhancing reliability.</li> </ul>"},{"location":"#8-health-checks","title":"8. Health Checks","text":"<ul> <li>Description: Implements health check endpoints to monitor the application's status and readiness.</li> <li>Benefit: Ensures the application is running correctly and is ready to handle requests, improving overall system stability.</li> </ul>"},{"location":"#9-prometheus-metrics","title":"9. Prometheus Metrics","text":"<ul> <li>Description: Integrates with Prometheus to expose metrics for monitoring.</li> <li>Benefit: Provides insights into application performance and resource usage, aiding in proactive management and optimization.</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To get started with Vault DB Injector, refer to the Installation Guide and Configuration Guide for detailed instructions on setting up and configuring the application.</p> <p>For a deeper understanding of how the application works, visit the How It Works section.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome contributions from the community! Please see our Contribution Guidelines for more information on how to get involved.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the MIT license. See the LICENSE file for details.</p>"},{"location":"#contact","title":"Contact","text":"<p>For any questions or support, please reach out to our team at support@numberly.com.</p>"},{"location":"getting-started/build/","title":"Build","text":""},{"location":"getting-started/build/#build","title":"Build","text":"<p>Requirements for building</p> <ul> <li>Go (built with version &gt;= 1.22)</li> </ul> <p>A Makefile is provided for building tasks. The options are as follows</p> <p>Getting started is as simple as:</p> <pre><code>go get -u github.com/numberly/vault-db-injector\ncd $GOPATH/src/github.com/numberly/vault-db-injector\nmake setup\nmake\n</code></pre>"},{"location":"getting-started/getting-started/","title":"getting-started","text":"<ul> <li> <ol> <li>Requirements</li> </ol> </li> <li> <ol> <li>Vocabulary</li> </ol> </li> <li> <ol> <li>Vault Configuration</li> <li>3.1. Create <code>all-rw</code> vault-policy</li> <li>3.2. Create <code>K/V Vault</code></li> <li>3.3. Create <code>vault databases mount</code></li> <li>3.4. Create <code>vault databases backend connection</code></li> <li>3.5. Create a <code>kubernetes auth backend</code></li> <li>3.6. Create a <code>kubernetes auth backend role</code></li> <li>3.7. Create <code>vault databases backend role</code></li> </ol> </li> <li> <ol> <li><code>Database</code> configuration</li> </ol> </li> <li> <ol> <li>Deploy the vault db injector</li> </ol> </li> <li> <ol> <li>Deploy an example application :</li> </ol> </li> </ul>"},{"location":"getting-started/getting-started/#1-requirements","title":"1. Requirements","text":"<p>To work correctly, the vault db injector need the following : </p> <ul> <li>A working Vault instance</li> <li>A working Kubernetes Cluster</li> <li>A Database Engine (Postgres/MariaDB/MySQL/Oracle/...)</li> </ul> <p>In this documentation, we assume that both of those following requirements are already installed.</p>"},{"location":"getting-started/getting-started/#2-vocabulary","title":"2. Vocabulary","text":"<p>Here are some vocabulary that you need before starting the installation.</p> name description default K/V Vault Vault KVv2 path for injector state vault-injector vault policy Vault Injector policy to work properly all-rw vault databases mount Vault database engine used to connect to our database databases vault databases backend connection Vault databases backend connection where we allow role to generate credentials rw-pgsql2-pr vault databases backend role Vault databases role used to allow application on specific database test-role kubernetes auth backend Vault Backend used by Kubernetes Application to authenticate under Vault kubernetes kubernetes auth backend role Vault Backend Role used by injector to authenticate under Vault all-rw postgresql Database engine used to connecte under vault rw-pgsql2-pr database database name to connect into test"},{"location":"getting-started/getting-started/#3-vault-configuration","title":"3. Vault Configuration","text":"<p>First, we need to configure Vault to allow the injector to generate credentials on the <code>databases</code> engine and to store them inside the dedicated <code>K/V Vault</code>.</p>"},{"location":"getting-started/getting-started/#31-create-all-rw-vault-policy","title":"3.1. Create <code>all-rw</code> vault-policy","text":"<p>We are going to start by create the <code>all-rw</code> <code>vault policy</code> that the injector will use :</p> <pre><code>path \"vault-injector/*\" {\n  capabilities = [\"read\", \"list\", \"update\", \"create\", \"delete\", \"sudo\"]\n}\npath \"vault-injector/data/*\" {\n  capabilities = [\"read\", \"list\", \"update\", \"create\", \"delete\", \"sudo\"]\n}\npath \"vault-injector/metadata/*\" {\n  capabilities = [\"read\", \"list\", \"update\", \"create\", \"delete\", \"sudo\"]\n}\npath \"rw-pgsql2-pr/creds/*\" {\n  capabilities = [\"read\"]\n}\npath \"auth/kubernetes/role/*\" {\n  capabilities = [\"read\"]\n}\npath \"sys/leases/renew\" {\n  capabilities = [\"create\"]\n}\npath \"auth/token/renew-self\" {\n  capabilities = [\"create\"]\n}\npath \"auth/token/renew\" {\n  capabilities = [\"create\", \"update\"]\n}\npath \"auth/token/revoke\" {\n  capabilities = [\"create\", \"update\"]\n}\npath \"auth/token/create\" {\n  capabilities = [\"create\", \"update\", \"read\"]\n}\npath \"auth/token/create-orphan\" {\n  capabilities = [\"create\", \"update\", \"read\", \"sudo\"]\n}\npath \"auth/token/revoke-orphan\" {\n  capabilities = [\"create\", \"update\", \"sudo\"]\n}\n</code></pre>"},{"location":"getting-started/getting-started/#32-create-kv-vault","title":"3.2. Create <code>K/V Vault</code>","text":"<p>We need to create the <code>K/V Vault</code> in version v2 named vault-injector.</p> <p>You can use the following documentation : vault-injector</p>"},{"location":"getting-started/getting-started/#33-create-vault-databases-mount","title":"3.3. Create <code>vault databases mount</code>","text":"<p>We need to create a <code>vault databases mount</code> engine named databases.</p> <p>Here is a terraform example : <pre><code>resource \"vault_mount\" \"databases\" {\n  path                  = \"databases\"\n  type                  = \"database\"\n  description           = \"databases authentication automation\"\n  max_lease_ttl_seconds = \"31536000\"\n}\n</code></pre></p>"},{"location":"getting-started/getting-started/#34-create-vault-databases-backend-connection","title":"3.4. Create <code>vault databases backend connection</code>","text":"<p>We need to create a <code>vault databases backend connection</code> on the vault <code>databases</code> engine. As you can see below, we allow the <code>test-role</code> role.</p> <p>Here is a terraform example :  <pre><code>resource \"vault_database_secret_backend_connection\" \"pgsql2\" {\n  backend = vault_mount.databases.path\n  name    = \"pgsql2\"\n  allowed_roles = [\n    \"test-role\",\n  ]\n\n  postgresql {\n    connection_url    = \"postgres://{{username}}:{{password}}@rw-pgsql2-pr:5432/postgres?sslmode=verify-full\"\n    username          = \"postgres\"\n    password          = \"my-password\"\n    username_template = \"{{.RoleName}}-{{unix_time}}-{{random 8}}\"\n  }\n}\n</code></pre></p>"},{"location":"getting-started/getting-started/#35-create-a-kubernetes-auth-backend","title":"3.5. Create a <code>kubernetes auth backend</code>","text":"<p>We need to create a <code>kubernetes auth backend</code> to allow serviceAccount to connect under Vault.</p> <p>You can use the following documentation : kubernetes</p>"},{"location":"getting-started/getting-started/#36-create-a-kubernetes-auth-backend-role","title":"3.6. Create a <code>kubernetes auth backend role</code>","text":"<p>We need to create a <code>kubernetes auth backend role</code> to allow the service account of the vault-db-injector to connect under Vault.</p> <p>Here is a terraform example :  <pre><code>resource \"vault_kubernetes_auth_backend_role\" \"all_rw\" {\n  backend                          = \"kubernetes\"\n  role_name                        = \"all-rw\"\n  bound_service_account_names      = [\"vault-db-injector\"]\n  bound_service_account_namespaces = [\"vault-db-injector\"]\n  token_ttl                        = 3600\n  token_policies                   = [vault_policy.all_rw.name] # remember the one created before\n  token_bound_cidrs                = [\"10.17.0.0/16\"] # Your pod CIDR\n}\n</code></pre></p> <p>We need to create a <code>kubernetes auth backend role</code> to allow the service account of our application to get generated credentials from vault Here is a terraform example :  <pre><code>resource \"vault_policy\" \"policy\" {\n  provider = vault.main\n  name     = var.service_account\n\n  policy = &lt;&lt;EOT\npath \"pgsql2/creds/test-role\" {\n  capabilities = [\"read\"]\n}\nEOT\n}\n\nresource \"vault_kubernetes_auth_backend_role\" \"role\" {\n  provider                         = vault.main\n  backend                          = kubernetes\n  role_name                        = \"test\"\n  bound_service_account_names      = [\"test\"]\n  bound_service_account_namespaces = [\"test\"]\n  token_ttl                        = 3600\n  token_policies                   = [vault_policy.policy.name]\n  token_bound_cidrs                = [\"10.17.0.0/16\"]\n}\n</code></pre></p>"},{"location":"getting-started/getting-started/#37-create-vault-databases-backend-role","title":"3.7. Create <code>vault databases backend role</code>","text":"<p>We need to create a <code>vault databases backend role</code> to allow our application to consume <code>vault databases backend connection</code></p> <p>Here is a terraform example : </p> <pre><code>resource \"vault_database_secret_backend_role\" \"role\" {\n  provider    = vault.main\n  backend     = \"databases\"\n  name        = test-role\n  db_name     = test\n  default_ttl = 3600\n  creation_statements = [\n    \"CREATE ROLE \\\"{{name}}\\\" WITH LOGIN PASSWORD '{{password}}' VALID UNTIL '{{expiration}}' IN ROLE \\\"test\\\";\",\n    \"ALTER ROLE \\\"{{name}}\\\" SET ROLE \\\"test\\\";\",\n  ]\n  revocation_statements = [\n    \"DROP ROLE \\\"{{name}}\\\";\"\n  ]\n}\n</code></pre>"},{"location":"getting-started/getting-started/#4-database-configuration","title":"4. <code>Database</code> configuration","text":"<p>You need to create you database under postgres, here is an example for postgres : </p> <pre><code>CREATE DATABASE test;\nCREATE ROLE test;\nrevoke all on database test from public cascade;\ngrant connect on database test to test;\n\\c test\ngrant create, usage on schema public to test;\ngrant temporary on database test to test;\nALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON TABLES TO test;\nREVOKE ALL ON pg_user FROM public;\nREVOKE ALL ON pg_roles FROM public;\nREVOKE ALL ON pg_group FROM public;\nREVOKE ALL ON pg_authid FROM public;\nREVOKE ALL ON pg_auth_members FROM public;\nREVOKE ALL ON pg_database FROM public;\nREVOKE ALL ON pg_tablespace FROM public;\nREVOKE ALL ON pg_settings FROM public;\n</code></pre>"},{"location":"getting-started/getting-started/#5-deploy-the-vault-db-injector","title":"5. Deploy the vault db injector","text":"<p>Now that you have a vault correctly configured and a database ready to be used, we can deploy our vault-db-injector application : </p> <p>For this, its quit easy, you just need to use the help chart.</p> <pre><code>kubectl create namespace vault-db-injector\nhelm upgrade --install vault-db-injector . --namespace vault-db-injector\n</code></pre> <p>When everything is Okay, you should have something like this :  <pre><code>NAME                                         READY   STATUS    RESTARTS   AGE\nvault-db-injector-7f74977b7c-88vvg           1/1     Running   0          29s\nvault-db-injector-7f74977b7c-rq6mt           1/1     Running   0          29s\nvault-db-injector-renewer-6496b84df-77skb    1/1     Running   0          29s\nvault-db-injector-renewer-6496b84df-96zz4    1/1     Running   0          29s\nvault-db-injector-renewer-6496b84df-tdp4r    1/1     Running   0          29s\nvault-db-injector-renewer-6496b84df-wpd8x    1/1     Running   0          29s\nvault-db-injector-revoker-7965857f75-2m5qp   1/1     Running   0          28s\nvault-db-injector-revoker-7965857f75-5msv6   1/1     Running   0          29s\nvault-db-injector-revoker-7965857f75-n29wp   1/1     Running   0          29s\nvault-db-injector-revoker-7965857f75-th9vs   1/1     Running   0          28s\n</code></pre></p>"},{"location":"getting-started/getting-started/#6-deploy-an-example-application","title":"6. Deploy an example application :","text":"<p>Here is an example application deploy on the namespace test that will connect to our database test with the service account test. <pre><code>apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: test\n  namespace: test\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  annotations:\n    db-creds-injector.numberly.io/test.env-key-uri: POSTGRES_URL\n    db-creds-injector.numberly.io/test.template: postgresql://@rw-pgsql2-pr:5432/test?sslmode=require\n    db-creds-injector.numberly.io/test.mode: uri\n    db-creds-injector.numberly.io/test.role: test-role\n  labels:\n    client: numberly\n    vault-db-injector: \"true\"\n  name: test\n  namespace: test\nspec:\n  containers:\n  - image: postgres:15.5\n    command: [\"/bin/bash\", \"-c\"]\n    args: [\"sleep 3000000\"]\n    name: test\n    resources: {}\n    securityContext:\n      allowPrivilegeEscalation: false\n      capabilities:\n        drop:\n        - ALL\n      readOnlyRootFilesystem: true\n      runAsNonRoot: true\n      runAsUser: 65534\n  dnsPolicy: ClusterFirst\n  restartPolicy: Always\n  serviceAccount: test\n  serviceAccountName: test\n</code></pre></p> <p>To deploy it :  <pre><code>kubectl apply -f test.yaml\n</code></pre></p> <p>Wait until your application is ready and you should be able to exec inside the pods and connect to the database.</p>"},{"location":"how-it-works/configuration/","title":"Configuration","text":"<pre><code>* 1. [Configuration](#Configuration)\n    * 1.1. [Mode Injector](#ModeInjector)\n    * 1.2. [Mode token-renewer](#Modetoken-renewer)\n    * 1.3. [Mode token-renewer](#Modetoken-renewer-1)\n</code></pre> <p>Here is the configuration for Vault Injector:</p>"},{"location":"how-it-works/configuration/#11-mode-injector","title":"1.1. Mode Injector","text":"<p>The Injector mode is basic one that will handle all api-server request and handle all requests to vault to generate credentials to our DB The config file path can be parse by adding the path with : <code>- \"--config=/injector/config.yaml\"</code> <pre><code>certFile: /tls/tls.crt\nkeyFile: /tls/tls.key\nvaultAddress: https://vault1.tld:8200\nvaultAuthPath: pgsql2-dv-kubernetes1-dv-par5\nlogLevel: info\nkubeRole: all-rw\ntokenTTL: 768h\nvaultSecretName: vault-injector\nvaultSecretPrefix: kubernetes1-dv-par5\nmode: injector\nsentry: true\nsentryDsn: https://my-sentry-url@sentry.tld/660\ninjectorLabel: vault-db-injector\ndefaultEngine: databases\n</code></pre></p>"},{"location":"how-it-works/configuration/#12-mode-token-renewer","title":"1.2. Mode token-renewer","text":"<p>The Renewer one is a process that will run every hour and validate that all orphan token won't expire before pod is deleted  The config file path can be parse by adding the path with : <code>- \"--config=/renewer/config.yaml\"</code> <pre><code>vaultAddress: https://vault1.tld:8200\nvaultAuthPath: pgsql2-dv-kubernetes1-dv-par5\nlogLevel: info\nkubeRole: all-rw\ntokenTTL: 768h\nvaultSecretName: vault-injector\nvaultSecretPrefix: kubernetes1-dv-par5\nmode: renewer\nsentry: true\nsentryDsn: https://my-sentry-url@sentry.tld/660\nSyncTTLSecond: 300\ninjectorLabel: vault-db-injector\ndefaultEngine: databases\n</code></pre></p>"},{"location":"how-it-works/configuration/#13-mode-token-renewer","title":"1.3. Mode token-renewer","text":"<p>The Revoker one is a process that is going to watch pod deletion Kubernetes events filtered with the label <code>vault-db-injector: true</code> and will revoke token attached to the pod when it is deleted  The config file path can be parse by adding the path with : <code>- \"--config=/revoker/config.yaml\"</code> <pre><code>vaultAddress: https://vault1.tld:8200\nvaultAuthPath: pgsql2-dv-kubernetes1-dv-par5\nlogLevel: info\nkubeRole: all-rw\ntokenTTL: 768h\nvaultSecretName: vault-injector\nvaultSecretPrefix: kubernetes1-dv-par5\nmode: revoker\nsentry: true\nsentryDsn: https://my-sentry-url@sentry.tld/660\ninjectorLabel: vault-db-injector\ndefaultEngine: databases\n</code></pre></p>"},{"location":"how-it-works/healthcheck/","title":"Health Checks","text":"<ul> <li> <ol> <li>How It Works:</li> </ol> </li> <li> <ol> <li>Key Responsibilities:</li> </ol> </li> <li> <ol> <li>Benefits:</li> </ol> </li> </ul> <p>Key File: <code>pkg/healthcheck/healthcheck.go</code></p>"},{"location":"how-it-works/healthcheck/#1-how-it-works","title":"1. How It Works:","text":"<p>Health Checks are a crucial feature that monitors the application's status and readiness, ensuring it is functioning correctly and is ready to handle requests. This feature provides endpoints that external systems can query to check the health and readiness of the application.</p>"},{"location":"how-it-works/healthcheck/#2-key-responsibilities","title":"2. Key Responsibilities:","text":"<ol> <li>Health Check Endpoints:</li> <li> <p>The application exposes HTTP endpoints for health (<code>/healthz</code>) and readiness (<code>/readyz</code>). These endpoints provide information about the application's operational status.</p> </li> <li> <p>Regular Monitoring:</p> </li> <li> <p>The health check service regularly monitors the internal state of the application and updates the health and readiness status accordingly.</p> </li> <li> <p>Integration with Kubernetes:</p> </li> <li>In a Kubernetes environment, these health check endpoints are used by Kubernetes to manage the application's lifecycle. Kubernetes can restart pods that fail health checks, ensuring continuous availability.</li> </ol>"},{"location":"how-it-works/healthcheck/#3-benefits","title":"3. Benefits:","text":"<ul> <li>Operational Reliability:</li> <li> <p>Health checks ensure that the application is running correctly and can handle incoming requests. This reliability is critical for maintaining user trust and satisfaction.</p> </li> <li> <p>Proactive Issue Detection:</p> </li> <li> <p>By regularly monitoring the application's status, health checks can detect issues early, allowing for proactive resolution before they impact users.</p> </li> <li> <p>Kubernetes Compatibility:</p> </li> <li>Health checks integrate seamlessly with Kubernetes, enabling automated management of the application's lifecycle. This integration helps maintain high availability and reduces downtime.</li> </ul>"},{"location":"how-it-works/how-it-work/","title":"How it Work","text":"<ul> <li> <ol> <li>Vault-Injector</li> <li>1.1. Mechanism<ul> <li>1.1.1. Vault Injector:</li> </ul> </li> <li>1.2. Diagram</li> <li>1.3. Vault Usage</li> <li>1.4. Authentication</li> <li>1.5. How token are handled ?</li> <li>1.6. How does injector work then ?</li> <li>1.7. Usage :<ul> <li>1.7.1. In mode classic</li> <li>1.7.2. In mode URI</li> <li>1.7.3. With multiple databases</li> </ul> </li> </ol> </li> </ul>"},{"location":"how-it-works/how-it-work/#1-vault-injector","title":"1. Vault-Injector","text":"<p>The Vault DB Injector is a Go program that is design to retrieve databases credentials from Hashicorp Vault, it use Kubernetes Mutating Webhook to intercept pod creation activated with a label and configured with annotations. After the credentials are provided, it will store them in a specific Vault KV and will handle the lifecycle of them such as :  - Renew them periodically - Revoke them after the pod is deleted </p>"},{"location":"how-it-works/how-it-work/#11-mechanism","title":"1.1. Mechanism","text":""},{"location":"how-it-works/how-it-work/#111-vault-injector","title":"1.1.1. Vault Injector:","text":"<ol> <li>Connects to Vault to generate credentials.</li> <li>Vault will create a temporary role in PostgreSQL for the database.</li> <li>Retrieves the credentials via Vault.</li> <li>Modifies the pod by adding the credentials in the form of environment variables.</li> <li>The pod can now connect to the database.</li> <li>Handle token / lease renewing and revokation.</li> </ol>"},{"location":"how-it-works/how-it-work/#12-diagram","title":"1.2. Diagram","text":""},{"location":"how-it-works/how-it-work/#13-vault-usage","title":"1.3. Vault Usage","text":"<p>Their is also a fonctionnality that permit to rotate token directly from the injector. Objectif is to keep token as secure as possible. For this purpose, we have made the choice to store the token directly on Vault in a specific KV. We provide a generated random UUID to every pod which will be use as a unique identifier. As long as the pod is alive, the injector will rotate his token 5 minutes by default. If the pods is deleted, the revoker will revoke the token and the lease and the renewer which is design to keep the state will also delete the secret in the KV.</p> <p>If the injector reboot or fail for any reason, the token can stil be renewed manually or by restarting the injector correctly. He can retrieve  all token that was created previously. The renewer will renew all tokens and leases every 5 minutes by default.</p> <p>We are using periodic token for this purpose which need absolutely \"sudo\" policy. Periodic token permit to add a max_ttl and to have infinite token that can be renewed until the pod is deleted. Token TTL permit to fix the max_ttl of the token which mean : \"How many time my token can belong without been renewed.\" By default, if the token is not renewed, hes timelife is 32 days, that mean, if the injector fail, you have 31 days and 23 hours before all your token will expire, which i think is enough to understand why and repair it to a working state.</p> <p>With this setup, the advantage is that now, vault is the only real SPOF. The Injector in renewer mode will only renew TOKEN and LEASE and cleanup KV/STORE that has been created by the Injector. The Injector in revoker mode will only revoke TOKEN when a pod has been deleted If the revoker fail to revoke a Token, the renewer can do it periodically every 5 minutes (This will be probably removed in future version.)</p>"},{"location":"how-it-works/how-it-work/#14-authentication","title":"1.4. Authentication","text":"<p>It uses a service account and the Kubernetes mount point to retrieve and generate its information. It then sends the following information to the application:</p> <ul> <li>Username: A database user generated by Vault.</li> <li>Password: A database password generated by Vault.</li> </ul> <p>It will store on a specific vault KV/Store the following : </p> <ul> <li>LeaseID</li> <li>TokenID</li> <li>Namespace</li> <li>UUID</li> </ul>"},{"location":"how-it-works/how-it-work/#15-how-token-are-handled","title":"1.5. How token are handled ?","text":"<p>They are two kind of token that are created in the lifecycle of the Vault injector : </p> <ol> <li>Token created for the Injector using <code>kubeRole:</code> in the yaml config</li> <li>Permit to generate OrphanToken for our pods that will access to DB</li> <li>Permit to renew and revoke all the OrphanToken</li> <li>Permit to store data token inside the KV from <code>vaultSecretName: vault-injector</code> and prefix : <code>vaultSecretPrefix: kubernetes1-dv-par5</code></li> <li>TTL is 1h but will always be revoked after the tasks is completed.</li> <li>This token will be revoked after the webhook is generated.</li> <li>OrphanToken created on a webhook request which are stored on Vault with the pods UUID and configured by annotation <code>db-creds-injector.numberly.io/role:</code> and <code>db-creds-injector.numberly.io/dbname.role:</code></li> <li>Permit to generate the LeaseId that will be provided to the pod</li> <li>Permit to generate the DB credentials</li> <li>Will be revoked when the pod is deleted</li> <li>Is a periodic token with TTL : <code>tokenTTL: 768h</code></li> </ol>"},{"location":"how-it-works/how-it-work/#16-how-does-injector-work-then","title":"1.6. How does injector work then ?","text":"<ol> <li>A new pod is created with label <code>vault-db-injector: \"true\"</code>, annotations <code>db-creds-injector.numberly.io/cluster:</code> &amp; <code>db-creds-injector.numberly.io/role:</code> and a serviceaccount</li> <li>The api-server use mutating-webhook to send the pods template to the injector</li> <li>The injector will generate a new orphan token and do thoses steps : </li> <li>Does the serviceaccount attached to my pod is allowed to assume my role on Vault. If the SA or the namespace is no't allowed, it will return an error, else, it will continue the process.</li> <li>Generate a new orphan token with a specific period and the policy provided in the annotation by the pod.</li> <li>Generate an UUID and add a specific annotation on the pod with IT</li> <li>Ask vault to generate DB Credentials for the pods with the new Orphan Token</li> <li>Store on vault on the specific KV the <code>LeaseId</code>, <code>TokenId</code>, <code>namespace</code> in a folder named with the pod UUID</li> <li>Revoke all intermediate Token</li> <li>The injector will return back to the api-server with a modified pod template</li> <li>The api-server will create the new pods with modified informations</li> </ol> <p>The available annotations can be declare like this : </p> <ul> <li><code>db-creds-injector.numberly.io/cluster</code>, [OPTIONAL] default to <code>databases</code> which is the database engine to use</li> <li><code>db-creds-injector.numberly.io/role</code>, [MANDATORY] Role to be use to get db credentials</li> <li><code>db-creds-injector.numberly.io/dbname.role</code>, [OPTIONAL] Role to be use to get db credentials for this specific database</li> <li><code>db-creds-injector.numberly.io/dbname.env-key-dbuser</code>, [OPTIONAL] overwrite DB user env variable, default to <code>DBUSER</code></li> <li><code>db-creds-injector.numberly.io/dbname.env-key-dbpassword</code>, [OPTIONAL] overwrite DB password env variable, default to <code>DBPASSWORD</code></li> <li><code>db-creds-injector.numberly.io/dbname.mode</code>, [MANDATORY] the mode for the injector, default to <code>classic</code>.</li> </ul>"},{"location":"how-it-works/how-it-work/#17-usage","title":"1.7. Usage :","text":""},{"location":"how-it-works/how-it-work/#171-in-mode-classic","title":"1.7.1. In mode classic","text":"<pre><code># To be added in the pod spec\nannotations:\n  db-creds-injector.numberly.io/cluster: databases\n  db-creds-injector.numberly.io/dbname.env-key-dbpassword: DB_PASSWORD\n  db-creds-injector.numberly.io/dbname.env-key-dbuser: DB_USER\n  db-creds-injector.numberly.io/dbname.role: db-role # the one created from vault with terraform\n  db-creds-injector.numberly.io/dbname.mode: classic\nlabels:\n  vault-db-injector: \"true\"\n</code></pre>"},{"location":"how-it-works/how-it-work/#172-in-mode-uri","title":"1.7.2. In mode URI","text":"<pre><code>annotations:\n  db-creds-injector.numberly.io/cluster: databases\n  db-creds-injector.numberly.io/dbname.template: postgres://@postgres-server.tld:5432/dbname?sslmode=require\n  db-creds-injector.numberly.io/dbname.role: db-role\n  db-creds-injector.numberly.io/dbname.env-key-uri: POSTGRES_URL\n  db-creds-injector.numberly.io/dbname.mode: uri\nlabels:\n  vault-db-injector: \"true\"\n</code></pre>"},{"location":"how-it-works/how-it-work/#173-with-multiple-databases","title":"1.7.3. With multiple databases","text":"<p><pre><code>annotations:\n  db-creds-injector.numberly.io/cluster: databases\n  db-creds-injector.numberly.io/dbname.env-key-dbpassword: DB_PASSWORD\n  db-creds-injector.numberly.io/dbname.env-key-dbuser: DB_USER\n  db-creds-injector.numberly.io/dbname.role: db-role # the one created from vault with terraform\n  db-creds-injector.numberly.io/dbname.mode: classic\n  db-creds-injector.numberly.io/other_dbname.template: postgres://@postgres-server.tld:5432/dbname?sslmode=require\n  db-creds-injector.numberly.io/other_dbname.role: another-vault-role\n  db-creds-injector.numberly.io/other_dbname.env-key-uri: POSTGRES_URL,ANOTHER_ENV\n  db-creds-injector.numberly.io/other_dbname.mode: uri\nlabels:\n  vault-db-injector: \"true\"\n</code></pre> Here, as you can see, we can connect to 2 databases <code>dbname</code> and <code>other_dbname</code>.</p>"},{"location":"how-it-works/injector/","title":"Injector","text":"<ul> <li> <ol> <li>How It Works:</li> </ol> </li> <li> <ol> <li>Benefits:</li> </ol> </li> </ul> <p>Key File: <code>pkg/injector/injector.go</code></p>"},{"location":"how-it-works/injector/#1-how-it-works","title":"1. How It Works:","text":"<p>The injector is responsible for injecting database credentials into Kubernetes Pods using a Mutating Admission Webhook.</p> <p></p> <ul> <li>Webhook Initialization:</li> <li>The injector sets up a webhook server that listens for Pod creation requests.</li> <li> <p>When a Pod is created, the webhook intercepts the request and modifies the Pod specification to include environment variables with the credentials.</p> </li> <li> <p>Credential Injection:</p> </li> <li>The injector retrieves credentials from Vault using the configured secrets path.</li> <li>It then injects these credentials into the Pod\u2019s environment variables.</li> </ul>"},{"location":"how-it-works/injector/#2-benefits","title":"2. Benefits:","text":"<ul> <li>Automatic Management:</li> <li> <p>By automating the injection of credentials, the injector ensures that Pods have the necessary credentials without storing them statically, enhancing security.</p> </li> <li> <p>Transparent Operation:</p> </li> <li> <p>The Mutating Admission Webhook operates transparently, modifying Pod specifications on-the-fly without manual intervention.</p> </li> <li> <p>Security:</p> </li> <li>Dynamic injection of credentials reduces the risk of credential leakage and ensures they are always fresh.</li> </ul>"},{"location":"how-it-works/kubernetes/","title":"Kubernetes Integration","text":"<ul> <li> <ol> <li>How It Works:</li> </ol> </li> <li> <ol> <li>Key Responsibilities:</li> </ol> </li> <li> <ol> <li>Benefits:</li> <li>3.1. Annotations :</li> </ol> </li> </ul> <p>Key Files: <code>pkg/k8s/connect.go</code>, <code>pkg/k8s/pod_utils.go</code>, <code>pkg/k8s/parse_annotations.go</code></p>"},{"location":"how-it-works/kubernetes/#1-how-it-works","title":"1. How It Works:","text":"<p>Kubernetes Integration is a fundamental feature that enables the application to interact with the Kubernetes API. This integration allows the application to manage and manipulate Kubernetes resources, facilitating tasks such as credential injection, pod management, and more.</p>"},{"location":"how-it-works/kubernetes/#2-key-responsibilities","title":"2. Key Responsibilities:","text":"<ol> <li>Kubernetes Client Initialization:</li> <li> <p>The application initializes a Kubernetes client that can interact with the Kubernetes API. This client is used to perform various operations such as reading pod annotations, accessing secrets, and more.</p> </li> <li> <p>Service Account Token Retrieval:</p> </li> <li> <p>The application retrieves the service account token from the Kubernetes environment. This token is used for authenticating API requests made by the application.</p> </li> <li> <p>CA Certificate Retrieval:</p> </li> <li> <p>The application retrieves the Kubernetes CA certificate. This certificate is used to establish secure communication with the Kubernetes API server.</p> </li> <li> <p>Pod Annotation Parsing:</p> </li> <li>The application reads and parses annotations from Kubernetes pods. These annotations can include instructions for credential injection and other custom configurations.</li> </ol>"},{"location":"how-it-works/kubernetes/#3-benefits","title":"3. Benefits:","text":"<ul> <li>Seamless Kubernetes Operations:</li> <li> <p>By integrating with the Kubernetes API, the application can perform a wide range of operations directly within the Kubernetes cluster. This seamless integration simplifies the management of Kubernetes resources.</p> </li> <li> <p>Security:</p> </li> <li> <p>Using service account tokens and CA certificates ensures that all interactions with the Kubernetes API are secure and authenticated. This enhances the security of the application's operations.</p> </li> <li> <p>Dynamic Configuration:</p> </li> <li>Parsing pod annotations allows the application to dynamically configure itself based on the specific needs of each pod. This dynamic configuration capability is particularly useful in diverse and changing environments.</li> </ul>"},{"location":"how-it-works/kubernetes/#31-annotations","title":"3.1. Annotations :","text":"<p>Each injector annotation are read by the Injector pod and permit to configure properly how Database Credetials need to be handled.</p>"},{"location":"how-it-works/leaderelection/","title":"Leader Election","text":"<ul> <li> <ol> <li>How It Works:</li> </ol> </li> <li> <ol> <li>Key Responsibilities:</li> </ol> </li> <li> <ol> <li>Benefits:</li> </ol> </li> </ul> <p>Key File: <code>pkg/leadership/leadership.go</code></p>"},{"location":"how-it-works/leaderelection/#1-how-it-works","title":"1. How It Works:","text":"<p>Leader Election is a mechanism that ensures high availability and fault tolerance by designating a single instance of the application to perform critical tasks at any given time. This feature is particularly important in distributed systems where multiple instances of an application might be running concurrently.</p>"},{"location":"how-it-works/leaderelection/#2-key-responsibilities","title":"2. Key Responsibilities:","text":"<ol> <li>Resource Locking:</li> <li> <p>Leader Election uses Kubernetes resource locks to manage which instance of the application is the current leader. The application instances compete for a lock, and the one that acquires it becomes the leader.</p> </li> <li> <p>Performing Critical Tasks:</p> </li> <li> <p>The leader is responsible for performing tasks that should not be duplicated. These tasks could include credential renewal, revocation, and other maintenance activities that need to be managed centrally.</p> </li> <li> <p>Failover Handling:</p> </li> <li>If the current leader fails or goes offline, another instance of the application can take over by acquiring the lock. This ensures continuous operation and minimal downtime for critical tasks.</li> </ol>"},{"location":"how-it-works/leaderelection/#3-benefits","title":"3. Benefits:","text":"<ul> <li>High Availability:</li> <li> <p>By ensuring that there is always one active leader performing critical tasks, the system can provide high availability and resilience. If the current leader fails, another instance takes over, maintaining operational continuity.</p> </li> <li> <p>Fault Tolerance:</p> </li> <li> <p>Leader Election allows the system to handle failures gracefully. The loss of a leader does not disrupt critical operations because another instance will quickly assume leadership.</p> </li> <li> <p>Efficient Resource Management:</p> </li> <li>Only the leader performs certain tasks, reducing the risk of conflicts and duplicated efforts. This efficient allocation of responsibilities helps maintain system stability.</li> </ul> <p>This feature is essential for applications deployed in Kubernetes clusters, where ensuring that critical tasks are managed by a single, designated instance enhances both reliability and performance.</p>"},{"location":"how-it-works/renewer/","title":"Renewer","text":"<ul> <li> <ol> <li>How It Works:</li> </ol> </li> <li> <ol> <li>Key Responsibilities:</li> </ol> </li> <li> <ol> <li>Benefits:</li> </ol> </li> </ul> <p>Key File: <code>pkg/renewer/renewer.go</code></p>"},{"location":"how-it-works/renewer/#1-how-it-works","title":"1. How It Works:","text":"<p>The Renewer is a crucial component responsible for ensuring that database credentials remain valid over time. It periodically checks the status of the credentials and renews them before they expire. This process is critical in environments where credentials have a limited lifespan and need to be refreshed to maintain access.</p> <p></p>"},{"location":"how-it-works/renewer/#2-key-responsibilities","title":"2. Key Responsibilities:","text":"<ol> <li>Periodic Checks:</li> <li> <p>The Renewer periodically checks the expiration status of the current database credentials. It ensures that credentials are always valid and do not reach their expiration date unnoticed.</p> </li> <li> <p>Credential Renewal:</p> </li> <li>Credentials are Renewed using Periodic Token so it ensure that during his whole lifetime, the application never need to restarted.</li> </ol>"},{"location":"how-it-works/renewer/#3-benefits","title":"3. Benefits:","text":"<ul> <li>Automatic Management:</li> <li> <p>By automating the renewal of credentials, the Renewer eliminates the need for manual intervention, reducing administrative overhead and the risk of human error.</p> </li> <li> <p>Continuous Availability:</p> </li> <li> <p>Ensures that applications have uninterrupted access to the database by renewing credentials well before they expire, thus preventing potential downtime.</p> </li> <li> <p>Security:</p> </li> <li>Regularly rotating credentials enhances security by limiting the lifespan of any single set of credentials, reducing the risk of credential compromise.</li> </ul> <p>This feature is particularly useful for maintaining secure and continuous database access in dynamic cloud environments, where credential rotation is a best practice for security.</p>"},{"location":"how-it-works/revoker/","title":"Revoker","text":"<ul> <li> <ol> <li>How It Works:</li> </ol> </li> <li> <ol> <li>Key Responsibilities:</li> </ol> </li> <li> <ol> <li>Benefits:</li> </ol> </li> </ul> <p>Key File: <code>pkg/revoker/revoker.go</code></p>"},{"location":"how-it-works/revoker/#1-how-it-works","title":"1. How It Works:","text":"<p>The Revoker is responsible for ensuring that unused or stale database credentials are properly revoked. This process is essential for maintaining the security of your system by ensuring that credentials that are no longer needed are not left active.</p> <p></p>"},{"location":"how-it-works/revoker/#2-key-responsibilities","title":"2. Key Responsibilities:","text":"<ol> <li>Identifying Stale Credentials:</li> <li> <p>The Revoker identifies credentials that are no longer in use or have become stale. This could be because the application instance that was using them has been terminated, or the credentials have exceeded their intended lifespan.</p> </li> <li> <p>Revoking Credentials:</p> </li> <li> <p>Once stale or unused credentials are identified, the Revoker sends a request to HashiCorp Vault to revoke these credentials. This action ensures that these credentials can no longer be used to access the database.</p> </li> <li> <p>Updating System State:</p> </li> <li> <p>The Revoker updates the system's state to reflect that certain credentials have been revoked. This helps in maintaining an accurate and secure overview of active and inactive credentials.</p> </li> <li> <p>Automatic revocation:</p> </li> <li>The Revoker is watching Kubernetes event and especially <code>DELETE</code> event on pod so it can revoke the credentials direcly after the pod is Deleted, this permit to be sure credentials are not revoked before the pods completely deleted.</li> </ol>"},{"location":"how-it-works/revoker/#3-benefits","title":"3. Benefits:","text":"<ul> <li>Enhanced Security:</li> <li> <p>By revoking unused or stale credentials, the Revoker minimizes the risk of unauthorized access. This is crucial in environments where security is a top priority.</p> </li> <li> <p>Reduced Attack Surface:</p> </li> <li> <p>Removing credentials that are no longer needed reduces the number of potential entry points for attackers, thus lowering the overall risk profile of the system.</p> </li> <li> <p>Compliance and Audit:</p> </li> <li>Regularly revoking credentials helps in complying with security policies and audit requirements. It demonstrates proactive management of access credentials.</li> </ul> <p>This feature is particularly important in dynamic environments where resources and their associated credentials are frequently created and destroyed. It ensures that credentials do not linger beyond their useful life, thereby maintaining a high standard of security.</p>"},{"location":"how-it-works/vault/","title":"Vault Integration","text":"<ul> <li> <ol> <li>How It Works:</li> </ol> </li> <li> <ol> <li>Key Responsibilities:</li> </ol> </li> <li> <ol> <li>Benefits:</li> </ol> </li> </ul> <p>Key Files: <code>pkg/vault/handle_token.go</code>, <code>pkg/vault/vault.go</code></p>"},{"location":"how-it-works/vault/#1-how-it-works","title":"1. How It Works:","text":"<p>Vault Integration is a crucial feature that handles interactions with HashiCorp Vault for generating and managing database credentials. This integration ensures that the application can securely request and use credentials from Vault.</p>"},{"location":"how-it-works/vault/#2-key-responsibilities","title":"2. Key Responsibilities:","text":"<ol> <li>Vault Client Initialization:</li> <li> <p>The application initializes a Vault client using the provided configuration. This client is used to authenticate and communicate with the Vault server.</p> </li> <li> <p>Authentication with Vault:</p> </li> <li> <p>The application authenticates with Vault using a Kubernetes authentication method</p> </li> <li> <p>Requesting Credentials:</p> </li> <li> <p>When the application needs database credentials, it sends a request to Vault. Vault generates the credentials and returns them to the application.</p> </li> <li> <p>Handling Tokens:</p> </li> <li>The application manages the tokens used to authenticate with Vault, including handling token renewal and revocation as needed.</li> </ol>"},{"location":"how-it-works/vault/#3-benefits","title":"3. Benefits:","text":"<ul> <li>Secure Credential Management:</li> <li> <p>By integrating with Vault, the application can securely manage database credentials. Vault ensures that credentials are generated securely and rotated regularly, enhancing overall security.</p> </li> <li> <p>Dynamic Credential Generation:</p> </li> <li> <p>Credentials are generated on demand, which means they are always fresh and have limited lifespans. This dynamic generation reduces the risk of credential compromise.</p> </li> <li> <p>Centralized Secret Management:</p> </li> <li>Vault acts as a central repository for managing secrets, providing a consistent and secure way to handle sensitive information across different environments and applications.</li> </ul>"},{"location":"monitoring/alertmanager/","title":"Alertmanager Configuration for VaultDb Injector","text":"<ul> <li> <ol> <li>Alerts Configuration</li> <li>1.1. Service Account Denied</li> <li>1.2. Token Renewal Failure</li> <li>1.3. Lease Renewal Failure</li> <li>1.4. Token Expiration Warnings</li> <li>1.5. Lease Expiration Warnings</li> </ol> </li> <li> <ol> <li>Conclusion</li> </ol> </li> </ul> <p>This configuration defines a set of alerts for monitoring the VaultDb Injector within a Kubernetes environment. Each alert is designed to notify the team of potential issues that could impact the availability, security, or functionality of the services relying on Vault for secret management.</p>"},{"location":"monitoring/alertmanager/#1-alerts-configuration","title":"1. Alerts Configuration","text":""},{"location":"monitoring/alertmanager/#11-service-account-denied","title":"1.1. Service Account Denied","text":"<pre><code>- alert: VaultDbInjectorServiceAccountDenied\n  annotations:\n    description: \"Service Account (SA) `{{ $labels.service_account_name }}` in namespace `{{ $labels.exported_namespace }}` was denied access to db_role `{{ $labels.db_role }}` due to `{{ $labels.cause }}` on cluster `{{ $labels.k8s_cluster }}`. Immediate investigation is recommended to ensure proper access controls and service configurations.\"\n    summary: \"Service Account `{{ $labels.service_account_name }}` in namespace `{{ $labels.exported_namespace }}` was denied by the injector.\"\n  expr: increase(vault_injector_service_account_denied_count{}[2m]) &gt; 0\n  for: 1m\n  labels:\n    severity: critical\n</code></pre> <p>Response Actions: - Verify the service account permissions and roles. - Check the db_role configurations to ensure they are correctly set up. - Investigate the cause for denial to prevent future occurrences.</p>"},{"location":"monitoring/alertmanager/#12-token-renewal-failure","title":"1.2. Token Renewal Failure","text":"<pre><code>- alert: VaultDbInjectorFailToRenewToken\n  annotations:\n    description: \"VaultDbInjector encountered an error while attempting to renew a token. This might affect the continuous operation of dependent services. Check for errors and ensure the token renewal process is configured correctly.\"\n    summary: \"VaultDbInjector token renewal failure for namespace `{{ $labels.exported_namespace }}` on cluster `{{ $labels.k8s_cluster }}`.\"\n  expr: increase(vault_injector_renew_token_count_error{}[2m]) &gt; 0\n  for: 1m\n  labels:\n    severity: warning\n</code></pre> <p>Response Actions: - Review the injector logs for errors related to token renewal. - Ensure the Vault policies allow for token renewal by the injector. - Check for network issues that might prevent the injector from communicating with Vault.</p>"},{"location":"monitoring/alertmanager/#13-lease-renewal-failure","title":"1.3. Lease Renewal Failure","text":"<pre><code>- alert: VaultDbInjectorFailToRenewLease\n  annotations:\n    description: \"VaultDbInjector encountered an error while attempting to renew a lease. Similar to token renewal failures, this can disrupt service operations if not addressed.\"\n    summary: \"VaultDbInjector lease renewal failure for namespace `{{ $labels.exported_namespace }}` on cluster `{{ $labels.k8s_cluster }}`.\"\n  expr: increase(vault_injector_renew_lease_count_error{}[2m]) &gt; 0\n  for: 1m\n  labels:\n    severity: warning\n</code></pre> <p>Response Actions: - Inspect the injector logs for specific errors related to lease renewal. - Confirm that the Vault configuration allows the injector to renew leases. - Investigate any network or configuration issues that might affect communication with Vault.</p>"},{"location":"monitoring/alertmanager/#14-token-expiration-warnings","title":"1.4. Token Expiration Warnings","text":"<pre><code>- alert: VaultDbInjectorTokenExpirationLessThan14Days\n  annotations:\n    description: \"A token is nearing expiration (less than 2 weeks). Renewing or rotating the token promptly ensures continuous service operation without interruption.\"\n    summary: \"Token nearing expiration in namespace `{{ $labels.exported_namespace }}` on cluster `{{ $labels.k8s_cluster }}`.\"\n  expr: vault_injector_token_expiration - time() &lt; 1209600\n  for: 90m\n  labels:\n    severity: warning\n\n- alert: VaultDbInjectorTokenExpirationLessThan7Days\n  annotations:\n    description: \"A token will expire in less than 7 days. Immediate action is required to renew or rotate the token to avoid service disruption.\"\n    summary: \"Urgent: Token expiration warning for namespace `{{ $labels.exported_namespace }}`.\"\n  expr: vault_injector_token_expiration - time() &lt; 604800\n  for: 5m\n  labels:\n    severity: critical\n</code></pre> <p>Response Actions: - For both alerts, identify the service or application using the token. - Initiate the token renewal or rotation process. - Review token policies to ensure they're aligned with security and operational requirements.</p>"},{"location":"monitoring/alertmanager/#15-lease-expiration-warnings","title":"1.5. Lease Expiration Warnings","text":"<pre><code>- alert: VaultDbInjectorLeaseExpirationLessThan4Days\n  annotations:\n    description: \"A lease is nearing expiration (less than 4 days). Addressing this promptly can prevent potential access issues for services relying on leased credentials or secrets.\"\n    summary: \"Lease nearing expiration for namespace `{{ $labels.namespace }}` on cluster `{{ $labels.k8s_cluster }}`.\"\n  expr: vault_injector_lease_expiration - time() &lt; 345600\n  for: 3m\n  labels:\n    severity: warning\n\n- alert: VaultDbInjectorLeaseExpirationLessThan1Day\n  annotations:\n    description: \"A lease will expire in less than 1 day. Immediate renewal is critical to maintaining access for the dependent services.\"\n    summary: \"Critical: Lease expiration imminent for namespace `{{ $labels.namespace }}`.\"\n  expr: vault_injector_lease_expiration - time() &lt; 86400\n  for: 3m\n  labels:\n    severity: critical\n</code></pre> <p>Response Actions: - Quickly identify and renew the leases for the affected services or credentials. - Review the lease durations and renewal policies to prevent future alerts.</p>"},{"location":"monitoring/alertmanager/#2-conclusion","title":"2. Conclusion","text":"<p>Monitoring VaultDb Injector with these alerts helps ensure the reliability and security of services depending on Vault for secret management and access control. Each alert is designed to provide actionable insights for maintaining operational efficiency and security compliance. Responding promptly to these alerts will mitigate potential risks and disruptions to your services.</p>"},{"location":"monitoring/grafana/","title":"Grafana","text":"<p>A grafana dashboard is available on the repository and permit you to easily monitore you vault-db-injector infrastructure.</p>"},{"location":"monitoring/grafana/#dashboard","title":"Dashboard","text":""},{"location":"monitoring/prometheus/","title":"1. Prometheus Metrics","text":"<p>Our application exports several Prometheus metrics for monitoring and observability purposes. Below are the details of the available metrics:</p> Metric Name Description Labels <code>vault_injector_renew_token_count_success</code> Vault injector token renewed with success count <code>uuid</code>, <code>namespace</code> <code>vault_injector_renew_token_count_error</code> Vault injector token renewed with error count <code>uuid</code>, <code>namespace</code> <code>vault_injector_renew_lease_count_success</code> Vault injector lease renewed with success count <code>uuid</code>, <code>namespace</code> <code>vault_injector_renew_lease_count_error</code> Vault injector lease renewed with error count <code>uuid</code>, <code>namespace</code> <code>vault_injector_revoke_token_count_success</code> Vault injector token revoked with success count <code>uuid</code>, <code>namespace</code> <code>vault_injector_revoke_token_count_error</code> Vault injector token revoked with error count <code>uuid</code>, <code>namespace</code> <code>vault_injector_token_expiration</code> Vault injector expiration time for tokens <code>uuid</code>, <code>namespace</code> <code>vault_injector_lease_expiration</code> Vault injector expiration time for leases <code>uuid</code>, <code>namespace</code> <code>vault_injector_token_last_renewed</code> Last vault token successful renewal <code>uuid</code>, <code>namespace</code> <code>vault_injector_synchronization_count_success</code> Vault injector synchronization with success <code>vault_injector_synchronization_count_error</code> Vault injector synchronization with error <code>vault_injector_pod_cleanup_count_success</code> Vault injector PodCleanup with success <code>vault_injector_pod_cleanup_count_error</code> Vault injector PodCleanup with error <code>vault_injector_last_synchronization_success</code> Last vault token successful renewal <code>vault_injector_orphan_ticket_created_count_success</code> Vault injector orphan ticket created with success <code>vault_injector_orphan_ticket_created_count_error</code> Vault injector orphan ticket created with error <code>vault_injector_store_data_count_success</code> Vault injector data stored with success <code>uuid</code>, <code>namespace</code> <code>vault_injector_store_data_count_error</code> Vault injector data stored with error <code>uuid</code>, <code>namespace</code> <code>vault_injector_delete_data_count_success</code> Vault injector data delete with success <code>uuid</code>, <code>namespace</code> <code>vault_injector_delete_data_count_error</code> Vault injector data deleted with error <code>uuid</code>, <code>namespace</code> <code>vault_injector_connect_vault_count_success</code> Vault injector connect to vault with success <code>vault_injector_connect_vault_count_error</code> Vault injector connect to vault with error <code>vault_injector_service_account_authorized_count</code> Vault injector service account is authorized to assume dbRole <code>vault_injector_service_account_denied_count</code> Vault injector service account is not authorized to assume dbRole <code>service_account_name</code>, <code>namespace</code>, <code>db_role</code>, <code>cause</code> <code>vault_injector_last_synchronization_duration</code> Vault injector last duration of synchronization <code>vault_injector_is_leader</code> Return 1 if the vault injector is leader, else 0 <code>lease_name</code> <code>vault_injector_leader_election_attempts_total</code> Total number of attempts to acquire leadership <code>lease_name</code> <code>vault_injector_leader_election_duration_seconds</code> Duration in seconds that this instance has been the leader <code>lease_name</code>, <code>leader_name</code>, <code>mode</code> <code>vault_injector_fetch_pods_success_count</code> Count that increase when their is no error retrieving pods <code>vault_injector_fetch_pods_error_count</code> Count that increase when their is an error retrieving pods <code>vault_injector_mutated_pods_error_count</code> Count that increase when their is an error mutating pods <code>vault_injector_mutated_pods_error_count</code> Count that increase when their is an error mutating pods"},{"location":"fr/getting-started/build/#construction","title":"Construction","text":"<p>Exigences pour la construction</p> <ul> <li>Go (construit avec la version &gt;= 1.22)</li> </ul> <p>Un Makefile est fourni pour les t\u00e2ches de construction. Les options sont les suivantes :</p> <p>Pour commencer, c'est aussi simple que :</p> <pre><code>go get -u github.com/numberly/vault-db-injector\ncd $GOPATH/src/github.com/numberly/vault-db-injector\nmake setup\nmake\n</code></pre>"}]}